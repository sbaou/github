import time
import numpy as np

# 項目9 大きな内包表記にはジェネレータ式を考える

'''
1. 冒頭

大規模なデータを入力対象とする場合は、膨大な量のメモリを
使用する事になるため、リスト内包表記は控えましょうという
お話。代わりにジェネレーター式を使用しましょう。
'''
# 入力が小さいデータサイズなら問題ない。
# でも入力が終わりのないネットワークソケットなら？
# →プログラムがクラッシュする可能性がある。

'''
2. ジェネレータ式の利用

上記の課題解決の為に、リスト内包表記とジェネレータを
一般化した'ジェネレータ式'を提供している。
ジェネレータ式は実行時に出力シーケンスを生成する事は
なく、その評価値をイテレータで1つずつ順番に取り出して
使用する。

イテレータとは何かという人はこちら。
https://uxmilk.jp/41512
'''

# 例　これはデータサイズ小さいからリスト内包表記でも問題ないけどね。
lst = [0, 1, 2, 3, 4, 5, 6, 7]

# ジェネレータ式には[]ではなく、()を使う。
buf = (x * 10 for x in lst)
print(buf) # 返り値は'generator object'となっているはず

print(next(buf))
print(next(buf))
# 一つずつ取り出せていますね。

'''
3. リスト内包表記との違い

リスト内包表記: 返り値はあくまでリスト。
            　データが大きくなれば確保しなきゃならないメモリ量も増える。

ジェネレータ式: 返り値は単一の評価値。イテレータで一つずつ処理する。
            　都度のメモリ確保と破棄をする為、データ量に依らない。
'''
# [], ()の違いを明記してみる。それぞれの実行結果に注目。

# 1.リスト内包表記
ret1 = [x * 10 for x in lst]
print(ret1)

# 2.ジェネレータ式
ret2 = (x * 10 for x in lst)
for i in ret2:
    print(i)

'''
4. 処理時間の比較

ではどれくらい処理時間に差があるでしょうか。
実際に配列を生成して、リスト内包表記とジェネレータ式に
同様の処理を実施させてみましょう。
'''
array = np.arange(0, 20000)

# リスト内包表記の場合
start_lst = time.time()
print([x * 10 for x in array])      # 2.6秒程度
print(time.time() - start_lst)

# ジェネレータ式の場合
start_gen = time.time()
for i in (x * 10 for x in array):
    print(i)
print(time.time() - start_gen)      # 0.6秒程度

# 約4倍くらいの処理時間差があります。
# ※扱うデータサイズ、PCスペック等に依存するため
# あくまで参考データです。

'''
5. まとめ

・リスト内包表記は入力データが大きすぎるとプログラムをクラッシュさせかねない。
・ジェネレータ式は、イテレータとして出力を1つずつ生成するので、メモリの心配がいらない。
・入力データサイズが大きくなると、ジェネレータ式を適用する方が高速動作する。

以上
'''
